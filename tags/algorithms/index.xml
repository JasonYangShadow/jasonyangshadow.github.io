<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Sep 2020 01:13:42 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Replace Elements With Greatest Element on the Right Side</title>
      <link>https://jasonyangshadow.github.io/posts/replace-elements-with-greatest-element-on-the-right-side/</link>
      <pubDate>Tue, 29 Sep 2020 01:13:42 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/replace-elements-with-greatest-element-on-the-right-side/</guid>
      <description>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.
After doing so, return the array.
Example 1:
Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1]
Constraints:
1 &amp;lt;= arr.length &amp;lt;= 10^4 1 &amp;lt;= arr[i] &amp;lt;= 10^5
class Solution: def replaceElements(self, arr: List[int]) -&amp;gt; List[int]: mx = -1 for i in range(len(arr) - 1, -1, -1): arr[i], mx = mx, max(arr[i], mx) return arr </description>
    </item>
    
    <item>
      <title>N Ary Tree Postorder Traversal</title>
      <link>https://jasonyangshadow.github.io/posts/n-ary-tree-postorder-traversal/</link>
      <pubDate>Tue, 29 Sep 2020 01:03:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/n-ary-tree-postorder-traversal/</guid>
      <description>https://leetcode.com/problems/n-ary-tree-postorder-traversal/
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children &amp;#34;&amp;#34;&amp;#34; class Solution: def postorder(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; List[int]: res = [] if not root: return res q = [root] while q: cur = q.pop() res.append(cur.val) q += cur.children return res[::-1] &amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children &amp;#34;&amp;#34;&amp;#34; class Solution: def postorder(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; List[int]: res = [] if not root: return res def helper(root, res): if not root: return for x in root.</description>
    </item>
    
    <item>
      <title>Producer Consumer Condition</title>
      <link>https://jasonyangshadow.github.io/posts/producer-consumer-condition/</link>
      <pubDate>Wed, 23 Sep 2020 03:19:36 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/producer-consumer-condition/</guid>
      <description>package com.company; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; class Message{ final private Lock lock = new ReentrantLock(); final private Condition c1 = lock.newCondition(); final private Condition c2 = lock.newCondition(); private String message; private boolean messageState; private boolean endIt; public void viewMessage(){ lock.lock(); try{ while(!messageState){ //if message is already consumed, hang myself up @c2  System.out.println(&amp;#34;c2 wait&amp;#34;); c2.await(); } System.out.println(&amp;#34;consume: &amp;#34; + message); messageState = false; c1.signal(); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>Split a String Inot the Max Number of Unique Substrings</title>
      <link>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</link>
      <pubDate>Mon, 21 Sep 2020 19:08:50 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</guid>
      <description>Given a string s, return the maximum number of unique substrings that the given string can be split into.
You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
A substring is a contiguous sequence of characters within a string.
Example 1: Input: s = &amp;quot;ababccc&amp;quot; Output: 5 Explanation: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;].</description>
    </item>
    
    <item>
      <title>Unique Paths 2</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths-2/</link>
      <pubDate>Mon, 21 Sep 2020 18:45:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths-2/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/
class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int: dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))] r, c = len(obstacleGrid), len(obstacleGrid[0]) dp[0][0] = 1 - obstacleGrid[0][0] for i in range(1, c): dp[0][i] = dp[0][i-1]*(1 - obstacleGrid[0][i]) for i in range(1, r): dp[i][0] = dp[i-1][0]*(1 - obstacleGrid[i][0]) for i in range(1, r): for j in range(1, c): dp[i][j] = (dp[i-1][j] + dp[i][j-1])*(1 - obstacleGrid[i][j]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>All Paths From Source to Target</title>
      <link>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</link>
      <pubDate>Mon, 21 Sep 2020 16:10:16 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</guid>
      <description>Given a directed acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.
The graph is given as follows: the nodes are 0, 1, &amp;hellip;, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.
Example: Input: [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:
0---&amp;gt;1 | | v v 2---&amp;gt;3 There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths/</link>
      <pubDate>Mon, 21 Sep 2020 15:46:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths/</guid>
      <description>https://leetcode.com/problems/unique-paths/
Recursive methods, will get TLE when m, n becomes larger
class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: def helper(i, j): if i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 or j == 0: return 1 return helper(i - 1, j) + helper(i, j - 1) return helper(m-1, n -1) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: aux = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i-1][j] + aux[i][j-1] return aux[-1][-1] </description>
    </item>
    
    <item>
      <title>Maximum Xor of Two Numbers in an Array</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Sat, 19 Sep 2020 22:48:18 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &amp;lt; n.
Follow up: Could you do this in O(n) runtime?
Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: Input: nums = [0] Output: 0 Example 3: Input: nums = [2,4] Output: 6 Example 4: Input: nums = [8,10,2] Output: 10 Example 5: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Sum of Root to Leaf Binary Numbers</title>
      <link>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Fri, 18 Sep 2020 00:57:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</guid>
      <description>https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumRootToLeaf(self, root: TreeNode) -&amp;gt; int: root_to_leaf = 0 stack = [(root, 0)] while stack: root, curr_num = stack.pop() if root is not None: curr_num = (curr_num&amp;lt;&amp;lt;1) | root.val if root.left is None and root.right is None: root_to_leaf += curr_num else: stack.</description>
    </item>
    
    <item>
      <title>Number of Islands 2</title>
      <link>https://jasonyangshadow.github.io/posts/number-of-islands-2/</link>
      <pubDate>Thu, 17 Sep 2020 12:52:38 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/number-of-islands-2/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
  </channel>
</rss>