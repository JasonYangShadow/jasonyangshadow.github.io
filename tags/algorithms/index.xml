<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 26 Aug 2020 17:38:59 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Detect Cycles in 2d Grid</title>
      <link>https://jasonyangshadow.github.io/posts/detect-cycles-in-2d-grid/</link>
      <pubDate>Wed, 26 Aug 2020 17:38:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/detect-cycles-in-2d-grid/</guid>
      <description>https://leetcode.com/problems/detect-cycles-in-2d-grid/
class Solution: def containsCycle(self, grid: List[List[str]]) -&amp;gt; bool: v = set() m,n = len(grid), len(grid[0]) def dfs(node, parent): if node in v: return True v.add(node) nx, ny = node childs = [(cx, cy) for cx ,cy in [[nx + 1, ny], [nx - 1, ny], [nx, ny + 1], [nx, ny-1]] if 0&amp;lt;= cx &amp;lt; m and 0&amp;lt;= cy &amp;lt; n and grid[nx][ny] == grid[cx][cy] and (cx,cy) != parent] for x in childs: if dfs(x, node): return True return False for i in range(m): for j in range(n): if (i,j) in v: continue else: if dfs((i, j), None): return True return False class DSU: def __init__(self, N): self.</description>
    </item>
    
    <item>
      <title>Minimum Numbers of Function Calls to Make Target Array</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-numbers-of-function-calls-to-make-target-array/</link>
      <pubDate>Wed, 26 Aug 2020 15:02:31 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-numbers-of-function-calls-to-make-target-array/</guid>
      <description>Your task is to form an integer array nums from an initial array of zeros arr that is the same size as nums.
Return the minimum number of function calls to make nums from arr.
The answer is guaranteed to fit in a 32-bit signed integer.
Example 1: Input: nums = [1,5] Output: 5 Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation). Double all the elements: [0, 1] -&amp;gt; [0, 2] -&amp;gt; [0, 4] (2 operations).</description>
    </item>
    
    <item>
      <title>Minimum Number of Vertices to Reach All Nodes</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-number-of-vertices-to-reach-all-nodes/</link>
      <pubDate>Wed, 26 Aug 2020 02:08:57 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-number-of-vertices-to-reach-all-nodes/</guid>
      <description>https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
The solution is easy, just check the indegree value of all nodes.
class Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: indegree = [0]*n for edge in edges: indegree[edge[1]] += 1 return [d for d in range(n) if indegree[d] == 0] </description>
    </item>
    
    <item>
      <title>Split Array Largest Sum</title>
      <link>https://jasonyangshadow.github.io/posts/split-array-largest-sum/</link>
      <pubDate>Thu, 20 Aug 2020 12:55:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-array-largest-sum/</guid>
      <description>Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
Note: If n is the length of array, assume the following constraints are satisfied:
1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) Examples:
Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays.</description>
    </item>
    
    <item>
      <title>Palladium 2020</title>
      <link>https://jasonyangshadow.github.io/posts/palladium-2020/</link>
      <pubDate>Wed, 19 Aug 2020 14:05:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/palladium-2020/</guid>
      <description>The problem description comes from here: https://pangeran-bottor.github.io/posts/2020/03/palladium-2020/
def solution(H): N = len(H) maxl = [0]*(N + 1) maxr = [0]*(N + 1) cmax = 0 #max value from left for i in range(N): cmax = max(cmax, H[i]) maxl[i + 1] = cmax cmax = 0 #max value from the right for i in range(N-1, -1, -1): cmax = max(cmax, H[i]) maxr[i] = cmax result = float(&amp;#34;inf&amp;#34;) for i in range(N + 1): #get the minimum value of current position result = min(result, maxl[i]*i + maxr[i]*(N-i)) return result print(solution([1,1,7,6,6,6])) </description>
    </item>
    
    <item>
      <title>Magnetic Force Between Two Balls</title>
      <link>https://jasonyangshadow.github.io/posts/magnetic-force-between-two-balls/</link>
      <pubDate>Mon, 17 Aug 2020 01:52:55 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/magnetic-force-between-two-balls/</guid>
      <description>https://leetcode.com/problems/magnetic-force-between-two-balls/
class Solution: def maxDistance(self, position: List[int], m: int) -&amp;gt; int: n = len(position) position.sort() #calculate how many balls can be put into basket #what we need is to find proper count(d) == m #if count(d) &amp;gt; m, meaning that d is too small otherwise, d is too large. def count(d): ans, cur = 1, position[0] for i in range(1, n): if position[i] - cur &amp;gt;= d: ans += 1 cur = position[i] return ans l, r = 0, position[-1] - position[0] #binary search while l &amp;lt; r: mid = r - (r-l) // 2 if count(mid) &amp;gt;= m: l = mid else: r = mid - 1 return l </description>
    </item>
    
    <item>
      <title>Minimum Number of Days to Eat N Oranges</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-eat-n-oranges/</link>
      <pubDate>Mon, 17 Aug 2020 01:03:08 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-eat-n-oranges/</guid>
      <description>There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:
Eat one orange. If the number of remaining oranges (n) is divisible by 2 then you can eat n/2 oranges. If the number of remaining oranges (n) is divisible by 3 then you can eat 2*(n/3) oranges. You can only choose one of the actions per day.
Return the minimum number of days to eat n oranges.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>https://jasonyangshadow.github.io/posts/lru-cache/</link>
      <pubDate>Sat, 15 Aug 2020 03:27:08 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/lru-cache/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Coin Change</title>
      <link>https://jasonyangshadow.github.io/posts/coin-change/</link>
      <pubDate>Fri, 14 Aug 2020 10:14:12 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/coin-change/</guid>
      <description>https://www.geeksforgeeks.org/coin-change-dp-7/
def solve(cents, target): dp = [0]*(target + 1) dp[0] = 1 #loop for all coins for i in range(len(cents)): #from current cent to target for j in range(cents[i], target + 1): #here dp[0] should be 1, as we need to add it to current value dp[j] += dp[j-cents[i]] return dp[-1] for _ in range(int(input())): input() cents = list(map(int, input().split())) target = int(input()) print(solve(cents, target)) </description>
    </item>
    
    <item>
      <title>Min Cost Path</title>
      <link>https://jasonyangshadow.github.io/posts/min-cost-path/</link>
      <pubDate>Fri, 14 Aug 2020 09:48:34 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/min-cost-path/</guid>
      <description>https://www.geeksforgeeks.org/min-cost-path-dp-6/
def solve(matrix, n): dp = [[0]*(n+1) for _ in range(n+1)] dp[0][0] = matrix[0][0] for i in range(1, n+1): dp[0][i] = dp[0][i-1] + matrix[0][i] dp[i][0] = dp[i-1][0] + matrix[i][0] for i in range(1, n+1): for j in range(1, n+1): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) return dp[-1][-1] </description>
    </item>
    
  </channel>
</rss>