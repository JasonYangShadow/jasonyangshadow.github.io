<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 21 Sep 2020 18:45:11 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unique Paths 2</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths-2/</link>
      <pubDate>Mon, 21 Sep 2020 18:45:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths-2/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/
class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int: dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))] r, c = len(obstacleGrid), len(obstacleGrid[0]) dp[0][0] = 1 - obstacleGrid[0][0] for i in range(1, c): dp[0][i] = dp[0][i-1]*(1 - obstacleGrid[0][i]) for i in range(1, r): dp[i][0] = dp[i-1][0]*(1 - obstacleGrid[i][0]) for i in range(1, r): for j in range(1, c): dp[i][j] = (dp[i-1][j] + dp[i][j-1])*(1 - obstacleGrid[i][j]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>All Paths From Source to Target</title>
      <link>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</link>
      <pubDate>Mon, 21 Sep 2020 16:10:16 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</guid>
      <description>Given a directed acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.
The graph is given as follows: the nodes are 0, 1, &amp;hellip;, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.
Example: Input: [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:
0---&amp;gt;1 | | v v 2---&amp;gt;3 There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths/</link>
      <pubDate>Mon, 21 Sep 2020 15:46:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths/</guid>
      <description>https://leetcode.com/problems/unique-paths/
Recursive methods, will get TLE when m, n becomes larger
class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: def helper(i, j): if i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 or j == 0: return 1 return helper(i - 1, j) + helper(i, j - 1) return helper(m-1, n -1) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: aux = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i-1][j] + aux[i][j-1] return aux[-1][-1] </description>
    </item>
    
    <item>
      <title>Maximum Xor of Two Numbers in an Array</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Sat, 19 Sep 2020 22:48:18 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &amp;lt; n.
Follow up: Could you do this in O(n) runtime?
Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: Input: nums = [0] Output: 0 Example 3: Input: nums = [2,4] Output: 6 Example 4: Input: nums = [8,10,2] Output: 10 Example 5: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Sum of Root to Leaf Binary Numbers</title>
      <link>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Fri, 18 Sep 2020 00:57:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</guid>
      <description>https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumRootToLeaf(self, root: TreeNode) -&amp;gt; int: root_to_leaf = 0 stack = [(root, 0)] while stack: root, curr_num = stack.pop() if root is not None: curr_num = (curr_num&amp;lt;&amp;lt;1) | root.val if root.left is None and root.right is None: root_to_leaf += curr_num else: stack.</description>
    </item>
    
    <item>
      <title>Number of Islands 2</title>
      <link>https://jasonyangshadow.github.io/posts/number-of-islands-2/</link>
      <pubDate>Thu, 17 Sep 2020 12:52:38 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/number-of-islands-2/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
    <item>
      <title>Sentence Screen Fitting</title>
      <link>https://jasonyangshadow.github.io/posts/sentence-screen-fitting/</link>
      <pubDate>Wed, 16 Sep 2020 11:41:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sentence-screen-fitting/</guid>
      <description>https://leetcode.com/problems/sentence-screen-fitting/
class Solution: def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&amp;gt; int: strs = &amp;#34;&amp;#34; for s in sentence: strs += s + &amp;#34; &amp;#34; start = 0 for r in range(rows): start = start + cols if strs[start % len(strs)] == &amp;#34; &amp;#34;: start += 1 else: while start &amp;gt; 0 and strs[(start - 1) % len(strs)] != &amp;#34; &amp;#34;: start -= 1 return start // len(strs) </description>
    </item>
    
    <item>
      <title>Group Shifted Strings</title>
      <link>https://jasonyangshadow.github.io/posts/group-shifted-strings/</link>
      <pubDate>Wed, 16 Sep 2020 11:39:07 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/group-shifted-strings/</guid>
      <description>Given a string, we can &amp;ldquo;shift&amp;rdquo; each of its letter to its successive letter, for example: &amp;ldquo;abc&amp;rdquo; -&amp;gt; &amp;ldquo;bcd&amp;rdquo;. We can keep &amp;ldquo;shifting&amp;rdquo; which forms the sequence:
&amp;ldquo;abc&amp;rdquo; -&amp;gt; &amp;ldquo;bcd&amp;rdquo; -&amp;gt; &amp;hellip; -&amp;gt; &amp;ldquo;xyz&amp;rdquo;
Given a list of non-empty strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.
Example:
Input: [&amp;ldquo;abc&amp;rdquo;, &amp;ldquo;bcd&amp;rdquo;, &amp;ldquo;acef&amp;rdquo;, &amp;ldquo;xyz&amp;rdquo;, &amp;ldquo;az&amp;rdquo;, &amp;ldquo;ba&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;z&amp;rdquo;], Output: [ [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;bcd&amp;rdquo;,&amp;ldquo;xyz&amp;rdquo;], [&amp;ldquo;az&amp;rdquo;,&amp;ldquo;ba&amp;rdquo;], [&amp;ldquo;acef&amp;rdquo;], [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;z&amp;rdquo;] ]</description>
    </item>
    
    <item>
      <title>Check if String Is Transformable With Substring Sort Operations</title>
      <link>https://jasonyangshadow.github.io/posts/check-if-string-is-transformable-with-substring-sort-operations/</link>
      <pubDate>Sun, 13 Sep 2020 16:59:28 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/check-if-string-is-transformable-with-substring-sort-operations/</guid>
      <description>https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/
solution:
Very tricky question! Probably the hardest part is to realize that: For every digit in t you find the first occurrence in s. Call that current digit as key. We need to make sure in s, no digit smaller than key appears to the left. As we check one-by-one, we need to remove the digits we considered from s. In order to do this operation constant time, store all indices in reversed form using stack.</description>
    </item>
    
    <item>
      <title>Min Cost to Connect All Points</title>
      <link>https://jasonyangshadow.github.io/posts/min-cost-to-connect-all-points/</link>
      <pubDate>Sun, 13 Sep 2020 15:42:58 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/min-cost-to-connect-all-points/</guid>
      <description>https://leetcode.com/problems/min-cost-to-connect-all-points/
we can use a min-heap to get the miniest edge distance and do it in a loop
class Solution: def minCostConnectPoints(self, points: List[List[int]]) -&amp;gt; int: dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) n, c = len(points), collections.defaultdict(list) #calculate the distance of every two points for i in range(n): for j in range(i + 1, n): d = dist(points[i], points[j]) c[i].append((d, j)) c[j].append((d, i)) cnt, ans, visited, heap = 1, 0, [0]*n, c[0] visited[0] = 1 heapq.</description>
    </item>
    
  </channel>
</rss>