<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 21 Sep 2020 19:08:50 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Split a String Inot the Max Number of Unique Substrings</title>
      <link>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</link>
      <pubDate>Mon, 21 Sep 2020 19:08:50 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</guid>
      <description>Given a string s, return the maximum number of unique substrings that the given string can be split into.
You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
A substring is a contiguous sequence of characters within a string.
Example 1: Input: s = &amp;quot;ababccc&amp;quot; Output: 5 Explanation: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;].</description>
    </item>
    
    <item>
      <title>Unique Paths 2</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths-2/</link>
      <pubDate>Mon, 21 Sep 2020 18:45:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths-2/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/
class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int: dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))] r, c = len(obstacleGrid), len(obstacleGrid[0]) dp[0][0] = 1 - obstacleGrid[0][0] for i in range(1, c): dp[0][i] = dp[0][i-1]*(1 - obstacleGrid[0][i]) for i in range(1, r): dp[i][0] = dp[i-1][0]*(1 - obstacleGrid[i][0]) for i in range(1, r): for j in range(1, c): dp[i][j] = (dp[i-1][j] + dp[i][j-1])*(1 - obstacleGrid[i][j]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>All Paths From Source to Target</title>
      <link>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</link>
      <pubDate>Mon, 21 Sep 2020 16:10:16 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</guid>
      <description>Given a directed acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.
The graph is given as follows: the nodes are 0, 1, &amp;hellip;, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.
Example: Input: [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:
0---&amp;gt;1 | | v v 2---&amp;gt;3 There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths/</link>
      <pubDate>Mon, 21 Sep 2020 15:46:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths/</guid>
      <description>https://leetcode.com/problems/unique-paths/
Recursive methods, will get TLE when m, n becomes larger
class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: def helper(i, j): if i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 or j == 0: return 1 return helper(i - 1, j) + helper(i, j - 1) return helper(m-1, n -1) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: aux = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i-1][j] + aux[i][j-1] return aux[-1][-1] </description>
    </item>
    
    <item>
      <title>Maximum Non Negative Product in a Matrix</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</link>
      <pubDate>Mon, 21 Sep 2020 15:09:47 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</guid>
      <description>You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.
Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.</description>
    </item>
    
    <item>
      <title>Maximum Xor of Two Numbers in an Array</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Sat, 19 Sep 2020 22:48:18 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &amp;lt; n.
Follow up: Could you do this in O(n) runtime?
Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: Input: nums = [0] Output: 0 Example 3: Input: nums = [2,4] Output: 6 Example 4: Input: nums = [8,10,2] Output: 10 Example 5: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Sum of Root to Leaf Binary Numbers</title>
      <link>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Fri, 18 Sep 2020 00:57:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</guid>
      <description>https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumRootToLeaf(self, root: TreeNode) -&amp;gt; int: root_to_leaf = 0 stack = [(root, 0)] while stack: root, curr_num = stack.pop() if root is not None: curr_num = (curr_num&amp;lt;&amp;lt;1) | root.val if root.left is None and root.right is None: root_to_leaf += curr_num else: stack.</description>
    </item>
    
    <item>
      <title>Number of Islands 2</title>
      <link>https://jasonyangshadow.github.io/posts/number-of-islands-2/</link>
      <pubDate>Thu, 17 Sep 2020 12:52:38 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/number-of-islands-2/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
    <item>
      <title>Sentence Screen Fitting</title>
      <link>https://jasonyangshadow.github.io/posts/sentence-screen-fitting/</link>
      <pubDate>Wed, 16 Sep 2020 11:41:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sentence-screen-fitting/</guid>
      <description>https://leetcode.com/problems/sentence-screen-fitting/
class Solution: def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&amp;gt; int: strs = &amp;#34;&amp;#34; for s in sentence: strs += s + &amp;#34; &amp;#34; start = 0 for r in range(rows): start = start + cols if strs[start % len(strs)] == &amp;#34; &amp;#34;: start += 1 else: while start &amp;gt; 0 and strs[(start - 1) % len(strs)] != &amp;#34; &amp;#34;: start -= 1 return start // len(strs) </description>
    </item>
    
    <item>
      <title>Group Shifted Strings</title>
      <link>https://jasonyangshadow.github.io/posts/group-shifted-strings/</link>
      <pubDate>Wed, 16 Sep 2020 11:39:07 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/group-shifted-strings/</guid>
      <description>Given a string, we can &amp;ldquo;shift&amp;rdquo; each of its letter to its successive letter, for example: &amp;ldquo;abc&amp;rdquo; -&amp;gt; &amp;ldquo;bcd&amp;rdquo;. We can keep &amp;ldquo;shifting&amp;rdquo; which forms the sequence:
&amp;ldquo;abc&amp;rdquo; -&amp;gt; &amp;ldquo;bcd&amp;rdquo; -&amp;gt; &amp;hellip; -&amp;gt; &amp;ldquo;xyz&amp;rdquo;
Given a list of non-empty strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.
Example:
Input: [&amp;ldquo;abc&amp;rdquo;, &amp;ldquo;bcd&amp;rdquo;, &amp;ldquo;acef&amp;rdquo;, &amp;ldquo;xyz&amp;rdquo;, &amp;ldquo;az&amp;rdquo;, &amp;ldquo;ba&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;z&amp;rdquo;], Output: [ [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;bcd&amp;rdquo;,&amp;ldquo;xyz&amp;rdquo;], [&amp;ldquo;az&amp;rdquo;,&amp;ldquo;ba&amp;rdquo;], [&amp;ldquo;acef&amp;rdquo;], [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;z&amp;rdquo;] ]</description>
    </item>
    
  </channel>
</rss>