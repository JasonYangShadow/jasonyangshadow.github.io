<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Sep 2020 01:13:42 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Replace Elements With Greatest Element on the Right Side</title>
      <link>https://jasonyangshadow.github.io/posts/replace-elements-with-greatest-element-on-the-right-side/</link>
      <pubDate>Tue, 29 Sep 2020 01:13:42 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/replace-elements-with-greatest-element-on-the-right-side/</guid>
      <description>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.
After doing so, return the array.
Example 1:
Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1]
Constraints:
1 &amp;lt;= arr.length &amp;lt;= 10^4 1 &amp;lt;= arr[i] &amp;lt;= 10^5
class Solution: def replaceElements(self, arr: List[int]) -&amp;gt; List[int]: mx = -1 for i in range(len(arr) - 1, -1, -1): arr[i], mx = mx, max(arr[i], mx) return arr </description>
    </item>
    
    <item>
      <title>N Ary Tree Postorder Traversal</title>
      <link>https://jasonyangshadow.github.io/posts/n-ary-tree-postorder-traversal/</link>
      <pubDate>Tue, 29 Sep 2020 01:03:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/n-ary-tree-postorder-traversal/</guid>
      <description>https://leetcode.com/problems/n-ary-tree-postorder-traversal/
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children &amp;#34;&amp;#34;&amp;#34; class Solution: def postorder(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; List[int]: res = [] if not root: return res q = [root] while q: cur = q.pop() res.append(cur.val) q += cur.children return res[::-1] &amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children &amp;#34;&amp;#34;&amp;#34; class Solution: def postorder(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; List[int]: res = [] if not root: return res def helper(root, res): if not root: return for x in root.</description>
    </item>
    
    <item>
      <title>Throne Inheritance</title>
      <link>https://jasonyangshadow.github.io/posts/throne-inheritance/</link>
      <pubDate>Sun, 27 Sep 2020 13:13:01 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/throne-inheritance/</guid>
      <description>https://leetcode.com/contest/weekly-contest-208/problems/throne-inheritance/
class ThroneInheritance: def __init__(self, kingName: str): self.kingName=kingName self.parentChild=defaultdict(list) self.deadMap={} self.order=[] def birth(self, parentName: str, childName: str) -&amp;gt; None: self.parentChild[parentName].append(childName) def death(self, name: str) -&amp;gt; None: self.deadMap[name]=1 def getInheritanceOrder(self) -&amp;gt; List[str]: self.order=[] self.printSuccessors(&amp;#34;king&amp;#34;) return self.order def printSuccessors(self,parent): if parent not in self.deadMap: self.order.append(parent) for i in self.parentChild[parent]: self.printSuccessors(i) # Your ThroneInheritance object will be instantiated and called as such: # obj = ThroneInheritance(kingName) # obj.birth(parentName,childName) # obj.death(name) # param_3 = obj.</description>
    </item>
    
    <item>
      <title>Split a String Inot the Max Number of Unique Substrings</title>
      <link>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</link>
      <pubDate>Mon, 21 Sep 2020 19:08:50 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</guid>
      <description>Given a string s, return the maximum number of unique substrings that the given string can be split into.
You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
A substring is a contiguous sequence of characters within a string.
Example 1: Input: s = &amp;quot;ababccc&amp;quot; Output: 5 Explanation: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;].</description>
    </item>
    
    <item>
      <title>Unique Paths 2</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths-2/</link>
      <pubDate>Mon, 21 Sep 2020 18:45:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths-2/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/
class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int: dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))] r, c = len(obstacleGrid), len(obstacleGrid[0]) dp[0][0] = 1 - obstacleGrid[0][0] for i in range(1, c): dp[0][i] = dp[0][i-1]*(1 - obstacleGrid[0][i]) for i in range(1, r): dp[i][0] = dp[i-1][0]*(1 - obstacleGrid[i][0]) for i in range(1, r): for j in range(1, c): dp[i][j] = (dp[i-1][j] + dp[i][j-1])*(1 - obstacleGrid[i][j]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>All Paths From Source to Target</title>
      <link>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</link>
      <pubDate>Mon, 21 Sep 2020 16:10:16 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</guid>
      <description>Given a directed acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.
The graph is given as follows: the nodes are 0, 1, &amp;hellip;, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.
Example: Input: [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:
0---&amp;gt;1 | | v v 2---&amp;gt;3 There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths/</link>
      <pubDate>Mon, 21 Sep 2020 15:46:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths/</guid>
      <description>https://leetcode.com/problems/unique-paths/
Recursive methods, will get TLE when m, n becomes larger
class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: def helper(i, j): if i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 or j == 0: return 1 return helper(i - 1, j) + helper(i, j - 1) return helper(m-1, n -1) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: aux = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i-1][j] + aux[i][j-1] return aux[-1][-1] </description>
    </item>
    
    <item>
      <title>Maximum Non Negative Product in a Matrix</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</link>
      <pubDate>Mon, 21 Sep 2020 15:09:47 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</guid>
      <description>You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.
Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.</description>
    </item>
    
    <item>
      <title>Maximum Xor of Two Numbers in an Array</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Sat, 19 Sep 2020 22:48:18 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &amp;lt; n.
Follow up: Could you do this in O(n) runtime?
Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: Input: nums = [0] Output: 0 Example 3: Input: nums = [2,4] Output: 6 Example 4: Input: nums = [8,10,2] Output: 10 Example 5: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Sum of Root to Leaf Binary Numbers</title>
      <link>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Fri, 18 Sep 2020 00:57:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</guid>
      <description>https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumRootToLeaf(self, root: TreeNode) -&amp;gt; int: root_to_leaf = 0 stack = [(root, 0)] while stack: root, curr_num = stack.pop() if root is not None: curr_num = (curr_num&amp;lt;&amp;lt;1) | root.val if root.left is None and root.right is None: root_to_leaf += curr_num else: stack.</description>
    </item>
    
  </channel>
</rss>