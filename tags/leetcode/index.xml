<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 30 Aug 2020 23:30:47 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Number of Ways to Reorder Array to Get Same Bst</title>
      <link>https://jasonyangshadow.github.io/posts/number-of-ways-to-reorder-array-to-get-same-bst/</link>
      <pubDate>Sun, 30 Aug 2020 23:30:47 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/number-of-ways-to-reorder-array-to-get-same-bst/</guid>
      <description>https://leetcode.com/contest/weekly-contest-204/problems/number-of-ways-to-reorder-array-to-get-same-bst/
We separate all the elements into two lists, depending on whether they are less than or more than the root. Then we recurse on those left and right sublists. The combination is for the macro ordering between left and right, and the recursive factors are for the internal ordering of left and right themselves. I minus 1 from the result because we don&amp;rsquo;t count the original ordering.
from math import comb class Solution: def numOfWays(self, nums: List[int]) -&amp;gt; int: def f(nums): if len(nums) &amp;lt; 2: return 1 left = [ v for v in nums if v &amp;lt; nums[0]] right = [ v for v in nums if v &amp;gt; nums[0]] return comb(len(left) + len(right), len(right))*f(left)*f(right) return (f(nums) - 1) %(10**9 + 7) </description>
    </item>
    
    <item>
      <title>Minimum Number of Days to Disconnect Island</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-disconnect-island/</link>
      <pubDate>Sun, 30 Aug 2020 22:09:32 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-disconnect-island/</guid>
      <description>https://leetcode.com/contest/weekly-contest-204/problems/minimum-number-of-days-to-disconnect-island/
The solution comes from here: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819807/PROOFProof-of-for-any-ISLAND-only-needs-2-days-to-disconnect
import copy class Solution: def minDays(self, grid: List[List[int]]) -&amp;gt; int: def helper(grid, i, j, m, n): if grid[i][j] == 0: return grid[i][j] = 0 if i - 1 &amp;gt;= 0: helper(grid, i-1, j, m,n) if i + 1 &amp;lt; m: helper(grid, i+1, j, m, n) if j - 1 &amp;gt;= 0: helper(grid, i, j - 1, m, n) if j + 1 &amp;lt; n: helper(grid, i, j + 1, m, n) def find_islands(grid): ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: ret += 1 helper(grid, i, j , m, n) return ret time = 0 #if we have 0 or more than 1 island at day 0, return day 0 gc = copy.</description>
    </item>
    
    <item>
      <title>Maximum Length of Subarray With Positive Product</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-length-of-subarray-with-positive-product/</link>
      <pubDate>Sun, 30 Aug 2020 19:15:47 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-length-of-subarray-with-positive-product/</guid>
      <description>Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.
A subarray of an array is a consecutive sequence of zero or more values taken out of that array.
Return the maximum length of a subarray with positive product.
Example 1: Input: nums = [1,-2,-3,4] Output: 4 Explanation: The array nums already has a positive product of 24. Example 2: Input: nums = [0,1,-2,-3,-4] Output: 3 Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.</description>
    </item>
    
    <item>
      <title>Most Visited Sector in a Circular Track</title>
      <link>https://jasonyangshadow.github.io/posts/most-visited-sector-in-a-circular-track/</link>
      <pubDate>Sat, 29 Aug 2020 20:44:31 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/most-visited-sector-in-a-circular-track/</guid>
      <description>https://leetcode.com/problems/most-visited-sector-in-a-circular-track/
We only need to care the start point and the end point. s ----- n 1 --------------------- n 1 --------------------- n 1 ----- e Explanation If start &amp;lt;= end, return the range [start, end]. If end &amp;lt; start, return the range [1, end] + range [start, n]. class Solution: def mostVisited(self, n: int, rounds: List[int]) -&amp;gt; List[int]: x, xx = rounds[0], rounds[-1] return list(range(x, xx+1)) if x &amp;lt;= xx else list(range(1, xx+1)) + list(range(x, n+1)) </description>
    </item>
    
    <item>
      <title>Detect Cycles in 2d Grid</title>
      <link>https://jasonyangshadow.github.io/posts/detect-cycles-in-2d-grid/</link>
      <pubDate>Wed, 26 Aug 2020 17:38:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/detect-cycles-in-2d-grid/</guid>
      <description>https://leetcode.com/problems/detect-cycles-in-2d-grid/
class Solution: def containsCycle(self, grid: List[List[str]]) -&amp;gt; bool: v = set() m,n = len(grid), len(grid[0]) def dfs(node, parent): if node in v: return True v.add(node) nx, ny = node childs = [(cx, cy) for cx ,cy in [[nx + 1, ny], [nx - 1, ny], [nx, ny + 1], [nx, ny-1]] if 0&amp;lt;= cx &amp;lt; m and 0&amp;lt;= cy &amp;lt; n and grid[nx][ny] == grid[cx][cy] and (cx,cy) != parent] for x in childs: if dfs(x, node): return True return False for i in range(m): for j in range(n): if (i,j) in v: continue else: if dfs((i, j), None): return True return False class DSU: def __init__(self, N): self.</description>
    </item>
    
    <item>
      <title>Minimum Numbers of Function Calls to Make Target Array</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-numbers-of-function-calls-to-make-target-array/</link>
      <pubDate>Wed, 26 Aug 2020 15:02:31 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-numbers-of-function-calls-to-make-target-array/</guid>
      <description>Your task is to form an integer array nums from an initial array of zeros arr that is the same size as nums.
Return the minimum number of function calls to make nums from arr.
The answer is guaranteed to fit in a 32-bit signed integer.
Example 1: Input: nums = [1,5] Output: 5 Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation). Double all the elements: [0, 1] -&amp;gt; [0, 2] -&amp;gt; [0, 4] (2 operations).</description>
    </item>
    
    <item>
      <title>Minimum Number of Vertices to Reach All Nodes</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-number-of-vertices-to-reach-all-nodes/</link>
      <pubDate>Wed, 26 Aug 2020 02:08:57 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-number-of-vertices-to-reach-all-nodes/</guid>
      <description>https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
The solution is easy, just check the indegree value of all nodes.
class Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: indegree = [0]*n for edge in edges: indegree[edge[1]] += 1 return [d for d in range(n) if indegree[d] == 0] </description>
    </item>
    
    <item>
      <title>Split Array Largest Sum</title>
      <link>https://jasonyangshadow.github.io/posts/split-array-largest-sum/</link>
      <pubDate>Thu, 20 Aug 2020 12:55:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-array-largest-sum/</guid>
      <description>Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
Note: If n is the length of array, assume the following constraints are satisfied:
1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) Examples:
Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays.</description>
    </item>
    
    <item>
      <title>Magnetic Force Between Two Balls</title>
      <link>https://jasonyangshadow.github.io/posts/magnetic-force-between-two-balls/</link>
      <pubDate>Mon, 17 Aug 2020 01:52:55 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/magnetic-force-between-two-balls/</guid>
      <description>https://leetcode.com/problems/magnetic-force-between-two-balls/
class Solution: def maxDistance(self, position: List[int], m: int) -&amp;gt; int: n = len(position) position.sort() #calculate how many balls can be put into basket #what we need is to find proper count(d) == m #if count(d) &amp;gt; m, meaning that d is too small otherwise, d is too large. def count(d): ans, cur = 1, position[0] for i in range(1, n): if position[i] - cur &amp;gt;= d: ans += 1 cur = position[i] return ans l, r = 0, position[-1] - position[0] #binary search while l &amp;lt; r: mid = r - (r-l) // 2 if count(mid) &amp;gt;= m: l = mid else: r = mid - 1 return l </description>
    </item>
    
    <item>
      <title>Minimum Number of Days to Eat N Oranges</title>
      <link>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-eat-n-oranges/</link>
      <pubDate>Mon, 17 Aug 2020 01:03:08 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/minimum-number-of-days-to-eat-n-oranges/</guid>
      <description>There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:
Eat one orange. If the number of remaining oranges (n) is divisible by 2 then you can eat n/2 oranges. If the number of remaining oranges (n) is divisible by 3 then you can eat 2*(n/3) oranges. You can only choose one of the actions per day.
Return the minimum number of days to eat n oranges.</description>
    </item>
    
  </channel>
</rss>