<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.github.io/</link>
    <description>Recent content on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 24 Feb 2020 13:43:41 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Throne Inheritance</title>
      <link>https://jasonyangshadow.github.io/posts/throne-inheritance/</link>
      <pubDate>Sun, 27 Sep 2020 13:13:01 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/throne-inheritance/</guid>
      <description>https://leetcode.com/contest/weekly-contest-208/problems/throne-inheritance/
class ThroneInheritance: def __init__(self, kingName: str): self.kingName=kingName self.parentChild=defaultdict(list) self.deadMap={} self.order=[] def birth(self, parentName: str, childName: str) -&amp;gt; None: self.parentChild[parentName].append(childName) def death(self, name: str) -&amp;gt; None: self.deadMap[name]=1 def getInheritanceOrder(self) -&amp;gt; List[str]: self.order=[] self.printSuccessors(&amp;#34;king&amp;#34;) return self.order def printSuccessors(self,parent): if parent not in self.deadMap: self.order.append(parent) for i in self.parentChild[parent]: self.printSuccessors(i) # Your ThroneInheritance object will be instantiated and called as such: # obj = ThroneInheritance(kingName) # obj.birth(parentName,childName) # obj.death(name) # param_3 = obj.</description>
    </item>
    
    <item>
      <title>Producer Consumer Condition</title>
      <link>https://jasonyangshadow.github.io/posts/producer-consumer-condition/</link>
      <pubDate>Wed, 23 Sep 2020 03:19:36 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/producer-consumer-condition/</guid>
      <description>package com.company; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; class Message{ final private Lock lock = new ReentrantLock(); final private Condition c1 = lock.newCondition(); final private Condition c2 = lock.newCondition(); private String message; private boolean messageState; private boolean endIt; public void viewMessage(){ lock.lock(); try{ while(!messageState){ //if message is already consumed, hang myself up @c2  System.out.println(&amp;#34;c2 wait&amp;#34;); c2.await(); } System.out.println(&amp;#34;consume: &amp;#34; + message); messageState = false; c1.signal(); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>Split a String Inot the Max Number of Unique Substrings</title>
      <link>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</link>
      <pubDate>Mon, 21 Sep 2020 19:08:50 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/split-a-string-inot-the-max-number-of-unique-substrings/</guid>
      <description>Given a string s, return the maximum number of unique substrings that the given string can be split into.
You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
A substring is a contiguous sequence of characters within a string.
Example 1: Input: s = &amp;quot;ababccc&amp;quot; Output: 5 Explanation: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;].</description>
    </item>
    
    <item>
      <title>Unique Paths 2</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths-2/</link>
      <pubDate>Mon, 21 Sep 2020 18:45:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths-2/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/
class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int: dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))] r, c = len(obstacleGrid), len(obstacleGrid[0]) dp[0][0] = 1 - obstacleGrid[0][0] for i in range(1, c): dp[0][i] = dp[0][i-1]*(1 - obstacleGrid[0][i]) for i in range(1, r): dp[i][0] = dp[i-1][0]*(1 - obstacleGrid[i][0]) for i in range(1, r): for j in range(1, c): dp[i][j] = (dp[i-1][j] + dp[i][j-1])*(1 - obstacleGrid[i][j]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>All Paths From Source to Target</title>
      <link>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</link>
      <pubDate>Mon, 21 Sep 2020 16:10:16 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/all-paths-from-source-to-target/</guid>
      <description>Given a directed acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.
The graph is given as follows: the nodes are 0, 1, &amp;hellip;, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.
Example: Input: [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:
0---&amp;gt;1 | | v v 2---&amp;gt;3 There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>https://jasonyangshadow.github.io/posts/unique-paths/</link>
      <pubDate>Mon, 21 Sep 2020 15:46:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/unique-paths/</guid>
      <description>https://leetcode.com/problems/unique-paths/
Recursive methods, will get TLE when m, n becomes larger
class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: def helper(i, j): if i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 or j == 0: return 1 return helper(i - 1, j) + helper(i, j - 1) return helper(m-1, n -1) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: aux = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i-1][j] + aux[i][j-1] return aux[-1][-1] </description>
    </item>
    
    <item>
      <title>Maximum Non Negative Product in a Matrix</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</link>
      <pubDate>Mon, 21 Sep 2020 15:09:47 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-non-negative-product-in-a-matrix/</guid>
      <description>You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.
Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.</description>
    </item>
    
    <item>
      <title>Maximum Xor of Two Numbers in an Array</title>
      <link>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Sat, 19 Sep 2020 22:48:18 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &amp;lt; n.
Follow up: Could you do this in O(n) runtime?
Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: Input: nums = [0] Output: 0 Example 3: Input: nums = [2,4] Output: 6 Example 4: Input: nums = [8,10,2] Output: 10 Example 5: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Sum of Root to Leaf Binary Numbers</title>
      <link>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Fri, 18 Sep 2020 00:57:03 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/sum-of-root-to-leaf-binary-numbers/</guid>
      <description>https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumRootToLeaf(self, root: TreeNode) -&amp;gt; int: root_to_leaf = 0 stack = [(root, 0)] while stack: root, curr_num = stack.pop() if root is not None: curr_num = (curr_num&amp;lt;&amp;lt;1) | root.val if root.left is None and root.right is None: root_to_leaf += curr_num else: stack.</description>
    </item>
    
    <item>
      <title>Number of Islands 2</title>
      <link>https://jasonyangshadow.github.io/posts/number-of-islands-2/</link>
      <pubDate>Thu, 17 Sep 2020 12:52:38 +0900</pubDate>
      
      <guid>https://jasonyangshadow.github.io/posts/number-of-islands-2/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
  </channel>
</rss>