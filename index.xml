<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xu YANG&#39;s Personal Website</title>
    <link>https://jasonyangshadow.win/</link>
    <description>Recent content on Xu YANG&#39;s Personal Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 20 Aug 2020 12:55:59 +0900</lastBuildDate>
    
	<atom:link href="https://jasonyangshadow.win/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Split Array Largest Sum</title>
      <link>https://jasonyangshadow.win/posts/split-array-largest-sum/</link>
      <pubDate>Thu, 20 Aug 2020 12:55:59 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/split-array-largest-sum/</guid>
      <description>Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
Note: If n is the length of array, assume the following constraints are satisfied:
1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) Examples:
Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays.</description>
    </item>
    
    <item>
      <title>Palladium 2020</title>
      <link>https://jasonyangshadow.win/posts/palladium-2020/</link>
      <pubDate>Wed, 19 Aug 2020 14:05:11 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/palladium-2020/</guid>
      <description>The problem description comes from here: https://pangeran-bottor.github.io/posts/2020/03/palladium-2020/
def solution(H): N = len(H) maxl = [0]*(N + 1) maxr = [0]*(N + 1) cmax = 0 #max value from left for i in range(N): cmax = max(cmax, H[i]) maxl[i + 1] = cmax cmax = 0 #max value from the right for i in range(N-1, -1, -1): cmax = max(cmax, H[i]) maxr[i] = cmax result = float(&amp;#34;inf&amp;#34;) for i in range(N + 1): #get the minimum value of current position result = min(result, maxl[i]*i + maxr[i]*(N-i)) return result print(solution([1,1,7,6,6,6])) </description>
    </item>
    
    <item>
      <title>Magnetic Force Between Two Balls</title>
      <link>https://jasonyangshadow.win/posts/magnetic-force-between-two-balls/</link>
      <pubDate>Mon, 17 Aug 2020 01:52:55 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/magnetic-force-between-two-balls/</guid>
      <description>https://leetcode.com/problems/magnetic-force-between-two-balls/
class Solution: def maxDistance(self, position: List[int], m: int) -&amp;gt; int: n = len(position) position.sort() #calculate how many balls can be put into basket #what we need is to find proper count(d) == m #if count(d) &amp;gt; m, meaning that d is too small otherwise, d is too large. def count(d): ans, cur = 1, position[0] for i in range(1, n): if position[i] - cur &amp;gt;= d: ans += 1 cur = position[i] return ans l, r = 0, position[-1] - position[0] #binary search while l &amp;lt; r: mid = r - (r-l) // 2 if count(mid) &amp;gt;= m: l = mid else: r = mid - 1 return l </description>
    </item>
    
    <item>
      <title>Minimum Number of Days to Eat N Oranges</title>
      <link>https://jasonyangshadow.win/posts/minimum-number-of-days-to-eat-n-oranges/</link>
      <pubDate>Mon, 17 Aug 2020 01:03:08 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/minimum-number-of-days-to-eat-n-oranges/</guid>
      <description>There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:
Eat one orange. If the number of remaining oranges (n) is divisible by 2 then you can eat n/2 oranges. If the number of remaining oranges (n) is divisible by 3 then you can eat 2*(n/3) oranges. You can only choose one of the actions per day.
Return the minimum number of days to eat n oranges.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>https://jasonyangshadow.win/posts/lru-cache/</link>
      <pubDate>Sat, 15 Aug 2020 03:27:08 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/lru-cache/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Coin Change</title>
      <link>https://jasonyangshadow.win/posts/coin-change/</link>
      <pubDate>Fri, 14 Aug 2020 10:14:12 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/coin-change/</guid>
      <description>https://www.geeksforgeeks.org/coin-change-dp-7/
def solve(cents, target): dp = [0]*(target + 1) dp[0] = 1 #loop for all coins for i in range(len(cents)): #from current cent to target for j in range(cents[i], target + 1): #here dp[0] should be 1, as we need to add it to current value dp[j] += dp[j-cents[i]] return dp[-1] for _ in range(int(input())): input() cents = list(map(int, input().split())) target = int(input()) print(solve(cents, target)) </description>
    </item>
    
    <item>
      <title>Min Cost Path</title>
      <link>https://jasonyangshadow.win/posts/min-cost-path/</link>
      <pubDate>Fri, 14 Aug 2020 09:48:34 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/min-cost-path/</guid>
      <description>https://www.geeksforgeeks.org/min-cost-path-dp-6/
def solve(matrix, n): dp = [[0]*(n+1) for _ in range(n+1)] dp[0][0] = matrix[0][0] for i in range(1, n+1): dp[0][i] = dp[0][i-1] + matrix[0][i] dp[i][0] = dp[i-1][0] + matrix[i][0] for i in range(1, n+1): for j in range(1, n+1): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>Edit Distance</title>
      <link>https://jasonyangshadow.win/posts/edit-distance/</link>
      <pubDate>Fri, 14 Aug 2020 08:36:57 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/edit-distance/</guid>
      <description>https://www.geeksforgeeks.org/edit-distance-dp-5/
def solve(s1, s2, l1, l2): dp = [[0]*(l2 + 1) for _ in range(l1 + 1)] for i in range(l1 + 1): for j in range(l2 + 1): #return j,as i is zero, all left items should be added if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: #different operations including remove, replace, insert dp[i][j] = 1 + min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) return dp[-1][-1] cases = int(input()) l1,l2 = list(map(int, input().</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>https://jasonyangshadow.win/posts/longest-increasing-subsequence/</link>
      <pubDate>Fri, 14 Aug 2020 07:18:53 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/longest-increasing-subsequence/</guid>
      <description>Description: https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/
def solve(arr): n = len(arr) dp = [1]*n for i in range(1, n): for j in range(0, i): #only if current item is larger than any other previous item, then update its value if arr[i] &amp;gt; arr[j] and dp[i] &amp;lt; dp[j] + 1: dp[i] = dp[j] + 1 return max(dp) cases = int(input()) for _ in range(cases): nums = int(input()) data = list(map(int, input().split())) print(solve(data)) </description>
    </item>
    
    <item>
      <title>Minimum Cost to Cut a Stick</title>
      <link>https://jasonyangshadow.win/posts/minimum-cost-to-cut-a-stick/</link>
      <pubDate>Sun, 09 Aug 2020 21:48:00 +0900</pubDate>
      
      <guid>https://jasonyangshadow.win/posts/minimum-cost-to-cut-a-stick/</guid>
      <description>https://leetcode.com/contest/weekly-contest-201/problems/minimum-cost-to-cut-a-stick/
The solution uses DFS+memo method, O(N^3)
class Solution: def minCost(self, n: int, cuts: List[int]) -&amp;gt; int: memo = {} def helper(l, r): res = float(&amp;#34;inf&amp;#34;) key = str(l) +&amp;#34;_&amp;#34; + str(r) if key in memo: return memo[key] for i in range(0, len(cuts)): if cuts[i] &amp;lt;= l or cuts[i] &amp;gt;= r: continue cost = r - l res = min(res, helper(l, cuts[i]) + cost + helper(cuts[i], r)) res = 0 if res == float(&amp;#34;inf&amp;#34;) else res memo[key] = res return res return helper(0, n) </description>
    </item>
    
  </channel>
</rss>